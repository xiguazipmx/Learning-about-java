并发

21.1 并发的多面性
用并发解决的问题大体上可分为“速度”和“设计可管理性”两种。
21.1.1 更快的执行（速度）
并发通常是提高运行在单处理器上的程序的性能
如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义
在单处理器系统中的性能提高的常见示例是事件驱动的编程。
实现并发最直接的方式是在操作系统级别使用进程。进程是运行在它自己的地址空间内的自包容的程序。
每个任务都作为进程在其自己的地址空间中执行，因此任务之间根本不可能互相干涉。对进程来说，它们之间没有任何彼此通信的需要，因为它们都是完全独立的。
函数型语言：某些编程语言被设计为可以将并发任务彼此隔离
java：在顺序型语言的基础上提供对线程的支持
21.1.2 改进代码设计
在java中，通常要假定你不会获得足够的现场，从而使得可以为大型仿真中的每个元素提供一个线程。
java的线程机制是抢占式的，这表示调度机制会周期性中断线程，将上下文切换到另一个线程。从而使每个线程都提供时间片，这表示调度机制会周期性地中断线程，将上下人切换到另一个线程，从而为每个线程提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。协作式系统的优势是双重的：上下文切换的开销通常比抢占式系统要低廉很多，并且对可以同时执行的线程数量在理论上没有任何限制。

21.2 基本的线程机制
并发编程使我们可以将程序划分为多个分离的，独立运行的任务。通过多线程机制，这些独立任务中的每一个都将由执行线程来驱动。
21.2.1 定义任务
public void run() {
	while(countDown-- > 0) {
		System.out.println(status());
		Thread.yield();
	}
}
Thread.yield()：线程调度器，执行下一个run()
21.2.2 Thread类
public static void main(String[] args) {	
	Thread thread = new Thread(new LiftOff());
	thread.start();
	System.out.println("Waiting for LiftOff!");
}
main()和LiftOff.run()方法同时执行
21.2.3 使用Executor（执行器）
Executor管理Thread对象。
ExecutorService eService = Executors.newCachedThreadPool();
eService.execute(new LiftOff());
eService.shutdown();
shutdown()方法的调用可以防止新任务提交给这个Executor,就是完成之后退出
21.2.4 从任务中产生返回值
21.2.5 休眠
sleep()
21.2.6 优先级
21.2.8 后台线程
所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可缺少的部分。因此，当所有的非后台线程结束时，程序终止，同时杀死进程中的所有后台线程。类似main()：非后台线程
必须在线程启动前调用setDaemon()方法，才能把它设置为后台线程。
Thread daemon = new Thread(new SimpleDaemons());
daemon.setDaemon(true);
daemon.start();
可以通过调用isDaemon()方法来确定线程是否是一个后台线程
21.2.9 编码的变体
21.2.10 术语
在java中，Thread类自身不执行任何操作，他只是驱动赋予他的任务。
21.2.11 加入一个线程
21.2.13 线程组
线程组持有一个线程集合，
21.2.14 捕获异常

21.3 共享受限资源
21.3.1 不正确地访问资源

